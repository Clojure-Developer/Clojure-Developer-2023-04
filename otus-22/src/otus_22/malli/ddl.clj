(ns otus-22.malli.ddl
  (:require [camel-snake-kebab.core :as csk]
            [clojure.string :as string]
            [malli.core :as m]))

(set! *warn-on-reflection* true)

(defn- non-nilable-spec
  [type]
  {:type type
   :nilable? false
   :primary-key? false
   :unique? false
   :generated nil})

(defn- update-spec
  [spec schema]
  (let [{::keys [primary-key?
                 unique?
                 generated]} (m/properties schema)]
    (cond-> spec
      primary-key? (assoc :primary-key? true)
      unique? (assoc :unique? true)
      (= generated :always) (assoc :generated :always)
      (= generated :by-defalt) (assoc :generated :by-defalt))))

(def ^:private unknown-spec
  nil)

(defn- spec->string
  [key spec]
  (let [{:keys [type
                nilable?
                primary-key?
                unique?
                generated]} spec]
    (cond-> (str "  \"" (-> key name csk/->snake_case_string) "\" " type)
      (= generated :by-defalt)
      (str " generated by default as identity")

      (= generated :always)
      (str " generated always as identity")

      primary-key?
      (str " primary key")

      (and (not primary-key?)
           unique?)
      (str " unique")

      (and (not primary-key?)
           (not nilable?))
      (str " not null"))))

(defprotocol DdlSchema
  "Protocol for transformer extension to new types of schemas."
  (-accept [this children options]
    "Transforms schema to DDL schema."))

(defmulti accept
  "Multimethod for transformation of schemas.
   Dispatching is carried out according to the schema type.
     * `type` - schema type;
     * `schema` - the original schema;
     * `children` - collection of transformed children;
     * `options` - map with additional options."
  (fn [type _schema _children _options]
    type)
  :default ::default)

(defmethod accept ::default [_ _ _ _] unknown-spec)

;; predicate-schemas
(defmethod accept 'integer? [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept 'int? [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept 'pos-int? [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept 'neg-int? [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept 'nat-int? [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept 'float? [_ schema _ _] (-> (non-nilable-spec "double precision") (update-spec schema)))
(defmethod accept 'double? [_ schema _ _] (-> (non-nilable-spec "double precision") (update-spec schema)))
(defmethod accept 'boolean? [_ schema _ _] (-> (non-nilable-spec "boolean") (update-spec schema)))
(defmethod accept 'string? [_ schema _ _] (-> (non-nilable-spec "text") (update-spec schema)))
(defmethod accept 'uuid? [_ schema _ _] (-> (non-nilable-spec "uuid") (update-spec schema)))
(defmethod accept 'inst? [_ schema _ _] (-> (non-nilable-spec "timestamp") (update-spec schema)))
(defmethod accept 'char? [_ schema _ _] (-> (non-nilable-spec "char(1)") (update-spec schema)))
(defmethod accept 'false? [_ schema _ _] (-> (non-nilable-spec "boolean") (update-spec schema)))
(defmethod accept 'true? [_ schema _ _] (-> (non-nilable-spec "boolean") (update-spec schema)))

;; type-schemas
(defmethod accept :string [_ schema _ _] (-> (non-nilable-spec "text") (update-spec schema)))
(defmethod accept :int [_ schema _ _] (-> (non-nilable-spec "integer") (update-spec schema)))
(defmethod accept :double [_ schema _ _] (-> (non-nilable-spec "double precision") (update-spec schema)))
(defmethod accept :boolean [_ schema _ _] (-> (non-nilable-spec "boolean") (update-spec schema)))
(defmethod accept :uuid [_ schema _ _] (-> (non-nilable-spec "uuid") (update-spec schema)))

;; base-schemas
(defmethod accept :maybe [_ _ children _]
  (if (and (= 1 (count children))
           (map? (first children)))
    (assoc (first children) :nilable? true)
    unknown-spec))

(defmethod accept ::m/val [_ schema children _]
  (-> (first children)
      (update-spec schema)))

(defmethod accept :map [_ schema children _]
  (let [unknown-result? (fn [[_k _p v]]
                          (nil? v))
        drop-properties (fn [[k _p v]]
                          [k v])
        convert-to-string (fn [[k v]]
                            (spec->string k v))
        processed-children (sequence (comp (remove unknown-result?)
                                           (map drop-properties)
                                           (map convert-to-string))
                                     children)
        {::keys [table]} (m/properties schema)

        _ (assert (some? table) "The table schema must contain the ::table property.")
        _ (assert (or (string? table)
                      (simple-keyword? table))
                  "The ::table property should be a simple keyword or string.")

        result (format "create table \"%s\" (\n%s\n);"
                       (name table)
                       (string/join ",\n" processed-children))]
    result))

(defn- sql-walker
  "A walker function that calls the accept fn for schema transofrmation."
  [schema _path children options]
  (if (satisfies? DdlSchema schema)
    (-accept schema children options)
    (accept (m/type schema) schema children options)))

(comment
  (defn- skip-walk
    ([?schema f]
     (skip-walk ?schema f nil))
    ([?schema f options]
     (let [schema (m/schema ?schema options)
           walker (reify m/Walker
                    (m/-accept [_ s _ _]
                      (when-not (::skip? (m/properties s))
                        s))

                    (m/-inner [this s p options]
                      (m/-walk s this p options))

                    (m/-outer [_ s p c options]
                      (f s p c options)))]
       (m/-walk schema walker [] options)))))

(defn transform
  ([?schema]
   (transform ?schema nil))
  ([?schema options]
   (m/walk ?schema sql-walker (merge options {::m/walk-entry-vals true}))))

(println (transform [:map {::table :account}
                     [:id {::generated :always ::primary-key? true} integer?]
                     [:username {::unique? true} string?]
                     [:password string?]
                     [:email {::unique? true} string?]
                     [:created-on inst?]]))
